//! Extraction of expression DAGs with algorithms that leverage sharing in the
//! EGraph.
use instant::{Duration, Instant};
use petgraph::prelude::NodeIndex;
use symbol_table::GlobalSymbol;

use crate::{ast::Expr, util::HashMap, EGraph, Value};

use super::Cost;

#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]
enum ENodeId {
    Prim(Value),
    EqAble { func: GlobalSymbol, offset: u32 },
}

struct DagExtractor<'a> {
    constructors: HashMap<GlobalSymbol, Vec<GlobalSymbol>>,
    egraph: &'a EGraph,
}

impl<'a> DagExtractor<'a> {
    fn new(egraph: &EGraph) -> DagExtractor {
        let mut constructors = HashMap::<GlobalSymbol, Vec<GlobalSymbol>>::default();
        for (func_name, func) in &egraph.functions {
            constructors
                .entry(func.schema.output.name())
                .or_default()
                .push(*func_name);
        }
        DagExtractor {
            egraph,
            constructors,
        }
    }
    fn get_tuple(&self, func: GlobalSymbol, offset: u32) -> (&[Value], Value) {
        let (inputs, output) = self.egraph.functions[&func]
            .nodes
            .get_index(offset as usize)
            .expect("offsets generated by extractor should be valid");
        (inputs, output.value)
    }
    fn render_dag(&self, result: &zdds::ExtractResult<ENodeId>) -> Vec<Expr> {
        let mut exprs = Vec::new();
        self.render_node(result, result.root, &mut Default::default(), &mut exprs);
        exprs
    }
    fn render_node(
        &self,
        result: &zdds::ExtractResult<ENodeId>,
        node: NodeIndex,
        mem: &mut HashMap<NodeIndex, GlobalSymbol>,
        res: &mut Vec<Expr>,
    ) -> GlobalSymbol {
        lazy_static::lazy_static! {
            static ref LET: GlobalSymbol = GlobalSymbol::from("let");
        }
        if let Some(sym) = mem.get(&node) {
            return *sym;
        }
        let weight = result.dag.node_weight(node).unwrap();
        let expr = match weight {
            ENodeId::Prim(v) => self.egraph.get_sort(v).unwrap().make_expr(*v),
            ENodeId::EqAble { func, .. } => {
                let mut args = Vec::new();
                for neigh in result.dag.neighbors(node) {
                    args.push(Expr::Var(self.render_node(result, neigh, mem, res)));
                }
                Expr::call(*func, args)
            }
        };
        let id: GlobalSymbol = format!("v{}", mem.len()).into();
        res.push(Expr::call(*LET, vec![Expr::Var(id), expr]));
        mem.insert(node, id);
        id
    }
}

impl<'a> zdds::Egraph for DagExtractor<'a> {
    type EClassId = Value;
    type ENodeId = ENodeId;
    fn cost(&self, node: &ENodeId) -> usize {
        match node {
            ENodeId::Prim(_) => 0,
            ENodeId::EqAble { func, .. } => {
                let func = &self.egraph.functions[func];
                func.decl.cost.unwrap_or(1)
            }
        }
    }
    fn expand_class(&mut self, class: &Value, nodes: &mut Vec<ENodeId>) {
        let sort = self.egraph.get_sort(class).expect("sort must be bound");
        if sort.is_eq_sort() {
            for func_name in &self.constructors[&class.tag] {
                let func = &self.egraph.functions[func_name];
                // TODO: confirm the indexes are up to date.
                let index = func.indexes.last().unwrap();
                for node in index.get(class).into_iter().flat_map(|x| {
                    x.iter().copied().filter_map(|offset| {
                        func.nodes.get_index(offset as usize)?;
                        Some(ENodeId::EqAble {
                            func: *func_name,
                            offset,
                        })
                    })
                }) {
                    nodes.push(node)
                }
            }
        } else {
            let node = ENodeId::Prim(*class);
            nodes.push(node);
        }
    }
    fn get_children(&mut self, node: &ENodeId, classes: &mut Vec<Value>) {
        match node {
            ENodeId::EqAble { func, offset } => {
                let (inputs, _) = self.get_tuple(*func, *offset);
                classes.extend(inputs.iter().copied());
            }
            ENodeId::Prim(_) => {}
        }
    }
}

const ZDD_NODE_LIMIT: Option<usize> = Some(4 << 10);

impl EGraph {
    /// Extract a sequence of expressions, the last of which yields a
    /// representative to `v`.
    ///
    /// This method uses ZDDs include sharing in the cost calculations.
    pub fn dag_zdd(&self, v: Value) -> Option<(Vec<Expr>, zdds::Report, Cost, Duration)> {
        let start = Instant::now();
        let mut extractor = DagExtractor::new(self);
        let (result, report) = zdds::extract_zdd(&mut extractor, v, ZDD_NODE_LIMIT)?;
        let exprs = extractor.render_dag(&result);
        let dur = Instant::now().duration_since(start);
        Some((exprs, report, result.total_cost.floor() as Cost, dur))
    }

    /// Extract a sequence of expressions, the last of which yields a
    /// representative to `v`.
    ///
    /// This uses a greedy algorithm which does not attempt to leverage sharing
    /// in the egraph. It is much faster than `dag_zdd`.
    pub fn dag_greedy(&self, v: Value) -> Option<(Vec<Expr>, Cost)> {
        let mut extractor = DagExtractor::new(self);
        let result = zdds::extract_greedy(&mut extractor, v)?;
        let exprs = extractor.render_dag(&result);
        Some((exprs, result.total_cost.floor() as Cost))
    }
}
